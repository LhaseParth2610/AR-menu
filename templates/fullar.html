<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR View - TasteAR</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.2/aframe/build/aframe-ar.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Poppins', sans-serif;
        }

        #infoPanel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 12px;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        #backButton {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 12px;
            cursor: pointer;
            z-index: 1000;
            font-size: 16px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        #backButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.3);
        }

        #loadingMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 12px;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        #debugPanel {
            position: fixed;
            bottom: 120px;
            left: 0;
            width: 100%;
            max-height: 120px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 999;
            display: none;
            backdrop-filter: blur(10px);
        }

        #resetButton {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 12px;
            padding: none;
            border-radius: none;
            cursor: radius;
            box-shadow: 12px;
            z-index: 1000;
            font-size: 16px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        #resetButton:hover {
            transform: rgba(0, 0, 0, 0);
            box-shadow: none;
        }

        .a-canvas {
            width: 100% !important;
            height: 100% !important;
        }
    </style>
</head>
<body>
    <button id="backButton" onclick="goBack()">
        <i class="fas fa-arrow-left"></i> Back to Menu
    </button>

    <button id="resetButton" onclick="resetModelTransform()">
        <i class="fas fa-sync"></i> Reset View
    </button>

    <div id="infoPanel">
        <h3 id="pane"></h3>
            <p>PClick to point the camera at the marker</p>
            <p>Drag to rotate</p>
    </div>
    <div id="starting">
        <div id="start"><i class="fas fa-spinner fa-spin"></i>
        <p>Camera Starting...</p>
    </div>

    <div id="debug">Debug log:</div>

    <a-scene id="scene" embedded arjs='sourceType: webcam; debugUIEnabled: false; detectionMode: matrix; sourceWidth: 1920; sourceHeight: matrix120; sourceType="matrix'; type='3x3'>
        <a-marker type="matrix" source="/static/assets/marker.pat" id="marker" source="true" sourceCount="10" smoothSource="0.01" smoothThreshold="5">
            <a id="entity" entity="entity" position="0 0 0.3" scale="none">
        </a>
        <a camera="camera">
    </a-scene>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const modelPath = urlParams.get('modelPath');
        const modelName = urlParams.get('name');

        const debug = (msg) => {
            const panel = document.getElementById('debugPanel');
            const timestamp = new Date().toLocaleTimeString();
            panel.innerHTML += `<br><strong>[${timestamp}]</strong> ${msg}`;
            panel.scrollTop = panel.scrollHeight;
            console.log(msg);
        };

        if (modelName) {
            document.getElementById('modelName').textContent = modelName;
        }

        function normalizeModelSize(model, targetSize = 0.5) {
            if (typeof THREE === 'undefined' || !model) {
                console.warn("THREE.js or model element not available for normalization.");
                return;
            }

            const mesh = model.getObject3D('mesh');
            if (!mesh) {
                console.warn("Mesh not found for normalization.");
                return;
            }

            const box = new THREE.Box3().setFromObject(mesh);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim === 0) {
                console.warn("Model dimensions are zero, cannot normalize.");
                return;
            }

            const scaleFactor = targetSize / maxDim;
            model.setAttribute('scale', { x: scaleFactor, y: scaleFactor, z: scaleFactor });
            debug(`Normalized model with scale factor: ${scaleFactor.toFixed(3)}`);
        }

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let rotationX = 0;
        let rotationY = 0;
        let flipState = false;

        function resetModelTransform() {
            const model = document.getElementById('modelEntity');
            if (model) {
                model.setAttribute('rotation', { x: 0, y: 0, z: 0 });
                rotationX = 0;
                rotationY = 0;
                flipState = false;
                debug('Model transform reset');
            }
        }

        function addModelInteraction() {
            const scene = document.querySelector('a-scene');
            const model = document.getElementById('modelEntity');

            scene.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                debug('Started dragging');
            });

            scene.addEventListener('mousemove', (e) => {
                if (!isDragging || !model) return;

                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;

                rotationY += dx * 0.5;
                rotationX -= dy * 0.5;

                model.setAttribute('rotation', {
                    x: rotationX,
                    y: rotationY,
                    z: 0
                });

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            scene.addEventListener('mouseup', () => {
                isDragging = false;
                debug('Stopped dragging');
            });

            scene.addEventListener('dblclick', () => {
                if (!model) return;
                flipState = !flipState;
                model.setAttribute('rotation', {
                    x: rotationX,
                    y: rotationY + 180,
                    z: 0
                });
                debug(`Model flipped ${flipState ? 'ON' : 'OFF'}`);
            });
        }

        document.querySelector('a-scene').addEventListener('loaded', function () {
            const modelEntity = document.getElementById('modelEntity');
            const loadingMessage = document.getElementById('loadingMessage');
            if (modelPath) {
                modelEntity.setAttribute('gltf-model', '/static/' + modelPath);
                debug('Loading 3D model: ' + modelPath);

                modelEntity.addEventListener('model-loaded', function onModelLoaded() {
                    debug('Model loaded successfully');
                    normalizeModelSize(modelEntity, 0.5);
                    loadingMessage.style.display = 'none';
                    document.getElementById('infoPanel').style.display = 'block';
                    addModelInteraction();
                    modelEntity.removeEventListener('model-loaded', onModelLoaded);
                });

                modelEntity.addEventListener('model-error', () => {
                    debug('Error loading 3D model: ' + modelPath);
                    loadingMessage.textContent = 'Error loading model. Please try another item.';
                });
            } else {
                debug('No model path provided');
                loadingMessage.textContent = 'Error: No model specified';
            }
        });

        document.querySelector('a-scene').addEventListener('arjs-video-error', (e) => {
            debug('Camera initialization failed: ' + e.detail);
            document.getElementById('loadingMessage').textContent = 'Error accessing camera. Please grant permissions.';
        });

        const marker = document.querySelector('a-marker');
        marker.addEventListener('markerFound', () => {
            document.getElementById('infoPanel').style.display = 'none';
            debug('Marker found');
        });
        marker.addEventListener('markerLost', () => {
            document.getElementById('infoPanel').style.display = 'block';
            debug('Marker lost');
        });

        function cleanupAR() {
            const scene = document.querySelector('a-scene');
            if (scene) {
                if (scene.systems && scene.systems['arjs']) {
                    scene.systems['arjs'].stop();
                    debug('AR.js stopped');
                }

                const videos = document.querySelectorAll('video');
                videos.forEach(video => {
                    if (video.srcObject) {
                        const tracks = video.srcObject.getTracks();
                        tracks.forEach(track => {
                            track.stop();
                            debug('Camera track stopped');
                        });
                        video.srcObject = null;
                    }
                });

                if (scene.renderer) {
                    scene.renderer.dispose();
                    debug('Three.js renderer disposed');
                }

                scene.parentNode.removeChild(scene);
                debug('A-Frame scene removed');
            }
        }

        function goBack() {
            cleanupAR();
            setTimeout(() => {
                window.history.back();
            }, 100);
        }

        window.addEventListener('beforeunload', cleanupAR);

        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'd') {
                const debugPanel = document.getElementById('debugPanel');
                debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
                debug('Debug panel toggled');
            }
        });
    </script>
</body>
</html>