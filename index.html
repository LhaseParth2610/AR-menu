<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Zero-Button WebXR AR Menu</title>
  <!-- Three.js & helpers -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/webxr/ARButton.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/loaders/GLTFLoader.js"></script>
  <style>body{margin:0;overflow:hidden;font-family:sans-serif}</style>
</head>
<body>
  <!-- 1) Big AR-launch overlay -->
  <div id="launcher">Tap to allow camera & enter AR</div>

  <!-- 2) Your on-screen swipe/UI hints -->
  <div id="ui" style="position:fixed;bottom:20px;width:100%;text-align:center;color:white;pointer-events:none">
    <span id="hint">Swipe to change dish</span>
  </div>

  <script>
  let scene,camera,renderer,reticle,models=[“dish1.glb”,”dish2.glb”],idx=0,current;
  const loader=new THREE.GLTFLoader();

  // 3) Set up Three.js scene
  function initScene() {
    scene    = new THREE.Scene();
    camera   = new THREE.PerspectiveCamera();
    renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Reticle for placement
    const geo = new THREE.RingGeometry(0.1,0.15,32).rotateX(-Math.PI/2);
    const mat = new THREE.MeshBasicMaterial({color:0x00ff00});
    reticle = new THREE.Mesh(geo,mat);
    reticle.visible = false;
    scene.add(reticle);
  }

  // 4) Start AR session on user gesture
  document.getElementById('launcher').addEventListener('click', async () => {
    document.getElementById('launcher').style.display = 'none';
    initScene();

    // Add the standardized ARButton—but hide it (we’re already in XR)
    document.body.appendChild(ARButton.createButton(renderer, {
      requiredFeatures: ['hit-test']
    })).style.display = 'none';

    // Load first model; we’ll swap it later
    loader.load(`models/${models[idx]}`, gltf => {
      current = gltf.scene; 
      current.scale.set(0.5,0.5,0.5);
    });

    // Hit-test setup
    const session = renderer.xr.getSession();
    const viewerSpace    = await session.requestReferenceSpace('viewer');
    const hitTestSource  = await session.requestHitTestSource({space:viewerSpace});
    const refSpace       = await session.requestReferenceSpace('local-floor');

    // Render loop
    renderer.setAnimationLoop((_,frame) => {
      if (frame) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length) {
          const pose = hits[0].getPose(refSpace);
          reticle.visible = true;
          reticle.position.set(pose.transform.position.x,
                               pose.transform.position.y,
                               pose.transform.position.z);

          // Auto-place model on first detection
          if (current && !current.parent) {
            current.position.copy(reticle.position);
            scene.add(current);
          }
        }
      }
      renderer.render(scene,camera);
    });
  });

  // 5) Swipe to change dish
  let touchStartX = null;
  window.addEventListener('touchstart', e => {
    touchStartX = e.touches[0].clientX;
  });
  window.addEventListener('touchend', e => {
    if (touchStartX === null) return;
    const dx = e.changedTouches[0].clientX - touchStartX;
    if (Math.abs(dx) > 50) {
      // remove old model
      if (current && current.parent) scene.remove(current);
      // pick next
      idx = (idx+1) % models.length;
      loader.load(`models/${models[idx]}`, gltf => {
        current = gltf.scene;
        current.scale.set(0.5,0.5,0.5);
        // place at existing reticle location
        if (reticle.visible) {
          current.position.copy(reticle.position);
          scene.add(current);
        }
      });
    }
    touchStartX = null;
  });
  </script>
</body>
</html>
