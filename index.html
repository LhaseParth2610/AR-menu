<!-- Session Initialization:

A WebXR session is started using navigator.xr.requestSession().
The session can be of type immersive-ar (for AR) or immersive-vr (for VR).
Reference Spaces:

WebXR uses "reference spaces" to define the coordinate system for the AR/VR environment.
Common reference spaces:
viewer: Tracks the user's head or device position.
local-floor: Tracks the user's position relative to the floor.
Hit Testing:

Hit testing is used to detect real-world surfaces.
A hit test source is created using session.requestHitTestSource().
During each frame, frame.getHitTestResults() is used to check for intersections between the real-world surfaces and the virtual objects.
Rendering:

WebXR provides a setAnimationLoop() method to render frames continuously during the session.
2. What is Three.js?
Three.js is a JavaScript library that simplifies 3D rendering in the browser. It abstracts the complexities of WebGL, making it easier to create 3D scenes, objects, and animations.

Key Features of Three.js
Scene Graph: Three.js uses a scene graph to manage 3D objects, lights, and cameras.
Geometry and Materials: It provides built-in geometries (e.g., cubes, spheres) and materials (e.g., basic, phong) for creating 3D objects.
WebXR Integration: Three.js has built-in support for WebXR, making it easier to create AR/VR experiences. -->


<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Zero-Button WebXR AR Menu</title>
  <!-- Three.js & helpers -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/webxr/ARButton.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/loaders/GLTFLoader.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    #launcher {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      cursor: pointer;
    }
    #ui {
      position: fixed;
      bottom: 20px;
      width: 100%;
      text-align: center;
      color: white;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- 1) Big AR-launch overlay -->
  <div id="launcher">
    Tap to allow camera & enter AR
  </div>

  <!-- 2) Your on-screen swipe/UI hints -->
  <div id="ui">
    <span id="hint">Swipe to change dish</span>
  </div>

  <script>
    let scene, camera, renderer, reticle, models = ["dish1.glb", "dish2.glb"], idx = 0, current;
    const loader = new THREE.GLTFLoader();

    // 3) Set up Three.js scene
    function initScene() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Reticle for placement
      const geo = new THREE.RingGeometry(0.1, 0.15, 32).rotateX(-Math.PI / 2);
      const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      reticle = new THREE.Mesh(geo, mat);
      reticle.visible = false;
      scene.add(reticle);
    }

    // 4) Start AR session on user gesture
    document.getElementById('launcher').addEventListener('click', async () => {
      try {
        // Show an alert to register the user gesture
        alert("Camera access is required to enter AR. Tap OK to continue.");

        // Hide the launcher overlay
        document.getElementById('launcher').style.display = 'none';

        // Initialize the scene
        initScene();

        // Add the standardized ARButton—but hide it (we’re already in XR)
        const arButton = ARButton.createButton(renderer, {
          requiredFeatures: ['hit-test']
        });
        document.body.appendChild(arButton);
        arButton.style.display = 'none';

        // Start the XR session
        await renderer.xr.setSession(await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test']
        }));

        // Load the first model
        loader.load(`models/${models[idx]}`, gltf => {
          current = gltf.scene;
          current.scale.set(0.5, 0.5, 0.5);
        });

        // Hit-test setup
        const session = renderer.xr.getSession();
        const viewerSpace = await session.requestReferenceSpace('viewer');
        const hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
        const refSpace = await session.requestReferenceSpace('local-floor');

        // Render loop
        renderer.setAnimationLoop((_, frame) => {
          if (frame) {
            const hits = frame.getHitTestResults(hitTestSource);
            if (hits.length) {
              const pose = hits[0].getPose(refSpace);
              reticle.visible = true;
              reticle.position.set(pose.transform.position.x,
                                   pose.transform.position.y,
                                   pose.transform.position.z);

              // Auto-place model on first detection
              if (current && !current.parent) {
                current.position.copy(reticle.position);
                scene.add(current);
              }
            }
          }
          renderer.render(scene, camera);
        });
      } catch (error) {
        console.error("Failed to start AR session:", error);
        alert("AR session could not be started. Please ensure your device supports WebXR.");
      }
    });

    // 5) Swipe to change dish
    let touchStartX = null;
    window.addEventListener('touchstart', e => {
      touchStartX = e.touches[0].clientX;
    });
    window.addEventListener('touchend', e => {
      if (touchStartX === null) return;
      const dx = e.changedTouches[0].clientX - touchStartX;
      if (Math.abs(dx) > 50) {
        // Remove old model
        if (current && current.parent) scene.remove(current);
        // Pick next
        idx = (idx + 1) % models.length;
        loader.load(`models/${models[idx]}`, gltf => {
          current = gltf.scene;
          current.scale.set(0.5, 0.5, 0.5);
          // Place at existing reticle location
          if (reticle.visible) {
            current.position.copy(reticle.position);
            scene.add(current);
          }
        });
      }
      touchStartX = null;
    });
  </script>
</body>
</html>